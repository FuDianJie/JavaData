<html lang="en"><head>
    <meta charset="UTF-8">
    <title></title>
<style id="system" type="text/css">h1,h2,h3,h4,h5,h6,p,blockquote {    margin: 0;    padding: 0;}body {    font-family: "Helvetica Neue", Helvetica, "Hiragino Sans GB", Arial, sans-serif;    font-size: 13px;    line-height: 18px;    color: #737373;    margin: 10px 13px 10px 13px;}a {    color: #0069d6;}a:hover {    color: #0050a3;    text-decoration: none;}a img {    border: none;}p {    margin-bottom: 9px;}h1,h2,h3,h4,h5,h6 {    color: #404040;    line-height: 36px;}h1 {    margin-bottom: 18px;    font-size: 30px;}h2 {    font-size: 24px;}h3 {    font-size: 18px;}h4 {    font-size: 16px;}h5 {    font-size: 14px;}h6 {    font-size: 13px;}hr {    margin: 0 0 19px;    border: 0;    border-bottom: 1px solid #ccc;}blockquote {    padding: 13px 13px 21px 15px;    margin-bottom: 18px;    font-family:georgia,serif;    font-style: italic;}blockquote:before {    content:"C";    font-size:40px;    margin-left:-10px;    font-family:georgia,serif;    color:#eee;}blockquote p {    font-size: 14px;    font-weight: 300;    line-height: 18px;    margin-bottom: 0;    font-style: italic;}code, pre {    font-family: Monaco, Andale Mono, Courier New, monospace;}code {    background-color: #fee9cc;    color: rgba(0, 0, 0, 0.75);    padding: 1px 3px;    font-size: 12px;    -webkit-border-radius: 3px;    -moz-border-radius: 3px;    border-radius: 3px;}pre {    display: block;    padding: 14px;    margin: 0 0 18px;    line-height: 16px;    font-size: 11px;    border: 1px solid #d9d9d9;    white-space: pre-wrap;    word-wrap: break-word;}pre code {    background-color: #fff;    color:#737373;    font-size: 11px;    padding: 0;}@media screen and (min-width: 768px) {    body {        width: 748px;        margin:10px auto;    }}</style><style id="custom" type="text/css"></style></head>
<body marginheight="0"><h1>0.学习目标</h1>
<ul>
<li>了解电商行业</li>
<li>了解乐优商城项目结构</li>
<li>能独立搭建项目基本框架</li>
<li>能参考使用ES6的新语法</li>
</ul>
<h1>1.了解电商行业</h1>
<p>学习电商项目，自然要先了解这个行业，所以我们首先来聊聊电商行业

</p>
<h2>1.1.项目分类</h2>
<p>主要从需求方、盈利模式、技术侧重点这三个方面来看它们的不同

</p>
<h3>1.1.1.传统项目</h3>
<p>各种企业里面用的管理系统（ERP、HR、OA、CRM、物流管理系统。。。。。。。）

</p>
<ul>
<li>需求方：公司、企业内部</li>
<li>盈利模式：项目本身卖钱</li>
<li>技术侧重点：业务功能</li>
</ul>
<h3>1.1.2.互联网项目</h3>
<p>门户网站、电商网站：baidu.com、qq.com、taobao.com、jd.com  ...... 

</p>
<ul>
<li>需求方：广大用户群体</li>
<li>盈利模式：虚拟币、增值服务、广告收益......</li>
<li>技术侧重点：网站性能、业务功能</li>
</ul>
<p>而我们今天要聊的就是互联网项目中的重要角色：电商



</p>
<h2>1.2.电商行业的发展</h2>
<h3>1.2.1.钱景</h3>
<p>近年来，中国的电子商务快速发展，交易额连创新高，电子商务在各领域的应用不断拓展和深化、相关服务业蓬勃发展、支撑体系不断健全完善、创新的动力和能力不断增强。电子商务正在与实体经济深度融合，进入规模性发展阶段，对经济社会生活的影响不断增大，正成为我国经济发展的新引擎。

</p>
<p>中国电子商务研究中心数据显示，截止到 2012 年底，中国电子商务市场交易规模达 7.85万亿人民币，同比增长 30.83%。其中，B2B 电子商务交易额达 6.25 万亿，同比增长 27%。而 2011 年全年，中国电子商务市场交易额达 6 万亿人民币，同比增长 33%，占 GDP 比重上升到 13%；2012 年，电子商务占 GDP 的比重已经高达 15%。

</p>
<pre><code> ![1525686041466](assets/1525686041466.png)</code></pre>
<h3>1.2.2.数据</h3>
<p>来看看双十一的成交数据：

</p>
<p><img src="assets/1525686135308.png" alt="1525686135308">

</p>
<p><img src="assets/1525686160411.png" alt="1525686160411">



</p>
<p>2016双11开场30分钟，创造<strong>每秒交易峰值17.5万笔</strong>，<strong>每秒</strong>支付峰值<strong>12万笔</strong>的新纪录。菜鸟单日物流订单量超过<strong>4.67亿</strong>，创历史新高。



</p>
<h3>1.2.3.技术特点</h3>
<p>从上面的数据我们不仅要看到钱，更要看到背后的技术实力。正是得益于电商行业的高强度并发压力，促使了BAT等巨头们的技术进步。电商行业有些什么特点呢？

</p>
<ul>
<li>技术范围广</li>
<li>技术新</li>
<li>高并发（分布式、静态化技术、缓存技术、异步并发、池化、队列）</li>
<li>高可用（集群、负载均衡、限流、降级、熔断）</li>
<li>数据量大</li>
<li>业务复杂</li>
<li>数据安全</li>
</ul>
<h2>1.3.常见电商模式</h2>
<p>电商行业的一些常见模式：

</p>
<ul>
<li>B2C：商家对个人，如：亚马逊、当当等</li>
<li>C2C平台：个人对个人，如：咸鱼、拍拍网、ebay</li>
<li>B2B平台：商家对商家，如：阿里巴巴、八方资源网等</li>
<li>O2O：线上和线下结合，如：饿了么、电影票、团购等</li>
<li>P2P：在线金融，贷款，如：网贷之家、人人聚财等。</li>
<li>B2C平台：天猫、京东、一号店等</li>
</ul>
<h2>1.4.一些专业术语</h2>
<ul>
<li><p>SaaS：软件即服务</p>
</li>
<li><p>SOA：面向服务</p>
</li>
<li><p>RPC：远程过程调用</p>
</li>
<li><p>RMI：远程方法调用</p>
</li>
<li><p>PV：(page view)，即页面浏览量；</p>
<p>用户每1次对网站中的每个网页访问均被记录1次。用户对同一页面的多次访问，访问量累计</p>
</li>
<li><p>UV：(unique visitor)，独立访客</p>
<p>指访问某个站点或点击某条新闻的不同IP地址的人数。在同一天内，uv只记录第一次进入网站的具有独立IP的访问者，在同一天内再次访问该网站则不计数。</p>
</li>
<li><p>PV与带宽：</p>
<ul>
<li>计算带宽大小需要关注两个指标：峰值流量和页面的平均大小。</li>
<li>计算公式是：网站带宽= ( PV <em> 平均页面大小（单位MB）</em> 8 )/统计时间（换算到秒）</li>
<li>为什么要乘以8？<ul>
<li>网站大小为单位是字节(Byte)，而计算带宽的单位是bit，1Byte=8bit</li>
</ul>
</li>
<li>这个计算的是平均带宽，高峰期还需要扩大一定倍数</li>
</ul>
</li>
<li><p>PV、QPS、并发</p>
<ul>
<li><p>QPS：每秒处理的请求数量。8000/s</p>
<ul>
<li>比如你的程序处理一个请求平均需要0.1S，那么1秒就可以处理10个请求。QPS自然就是10，多线程情况下，这个数字可能就会有所增加。</li>
</ul>
</li>
<li><p>由PV和QPS如何需要部署的服务器数量？</p>
<ul>
<li>根据二八原则，80%的请求集中在20%的时间来计算峰值压力：</li>
<li>（每日PV <em> 80%） / （3600s </em> 24 <em> 20%） </em> 每个页面的请求数  = 每个页面每秒的请求数量</li>
<li>然后除以服务器的QPS值，即可计算得出需要部署的服务器数量</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2>1.5.项目开发流程</h2>
<p>项目经理：管人

</p>
<p>产品经理：设计需求原型

</p>
<p>测试：

</p>
<p>前端：大前端。node

</p>
<p>后端：

</p>
<p>移动端：

</p>
<p>项目开发流程图：

</p>
<p>​    <img src="assets/1525697632643.png" alt="1525697632643">    

</p>
<p>公司现状：

</p>
<p>​    <img src="assets/1525697681975.png" alt="1525697681975">



</p>
<h1>2.乐优商城介绍</h1>
<h2>2.1.项目介绍</h2>
<ul>
<li>乐优商城是一个全品类的电商购物网站（B2C）。</li>
<li>用户可以在线购买商品、加入购物车、下单、秒杀商品</li>
<li>可以品论已购买商品</li>
<li>管理员可以在后台管理商品的上下架、促销活动</li>
<li>管理员可以监控商品销售状况</li>
<li>客服可以在后台处理退款操作</li>
<li>希望未来3到5年可以支持千万用户的使用</li>
</ul>
<h2>2.2.系统架构</h2>
<h3>2.2.1.架构图</h3>
<p>乐优商城架构缩略图，大图请参考课前资料：

</p>
<p><img src="assets/1525703759035.png" alt="1525703759035">



</p>
<h3>2.2.2.系统架构解读</h3>
<p>整个乐优商城可以分为两部分：后台管理系统、前台门户系统。

</p>
<ul>
<li><p>后台管理：</p>
<ul>
<li>后台系统主要包含以下功能：<ul>
<li>商品管理，包括商品分类、品牌、商品规格等信息的管理</li>
<li>销售管理，包括订单统计、订单退款处理、促销活动生成等</li>
<li>用户管理，包括用户控制、冻结、解锁等</li>
<li>权限管理，整个网站的权限控制，采用JWT鉴权方案，对用户及API进行权限控制</li>
<li>统计，各种数据的统计分析展示</li>
</ul>
</li>
<li>后台系统会采用前后端分离开发，而且整个后台管理系统会使用Vue.js框架搭建出单页应用（SPA）。</li>
<li>预览图：</li>
</ul>
<p><img src="assets/1525704185158.png" alt="1525704185158"></p>
</li>
<li><p>前台门户</p>
<ul>
<li>前台门户面向的是客户，包含与客户交互的一切功能。例如：<ul>
<li>搜索商品</li>
<li>加入购物车</li>
<li>下单</li>
<li>评价商品等等</li>
</ul>
</li>
<li>前台系统我们会使用Thymeleaf模板引擎技术来完成页面开发。出于SEO优化的考虑，我们将不采用单页应用。</li>
</ul>
<p><img src="assets/1525704277126.png" alt="1525704277126"></p>
</li>
</ul>
<p>无论是前台还是后台系统，都共享相同的微服务集群，包括：

</p>
<ul>
<li>商品微服务：商品及商品分类、品牌、库存等的服务</li>
<li>搜索微服务：实现搜索功能</li>
<li>订单微服务：实现订单相关</li>
<li>购物车微服务：实现购物车相关功能</li>
<li>用户中心：用户的登录注册等功能</li>
<li>Eureka注册中心</li>
<li>Zuul网关服务</li>
<li>Spring Cloud Config配置中心</li>
<li>...</li>
</ul>
<h1>3.项目搭建</h1>
<h2>3.1.技术选型</h2>
<p>前端技术：

</p>
<ul>
<li>基础的HTML、CSS、JavaScript（基于ES6标准）</li>
<li>JQuery</li>
<li>Vue.js 2.0以及基于Vue的框架：Vuetify</li>
<li>前端构建工具：WebPack</li>
<li>前端安装包工具：NPM</li>
<li>Vue脚手架：Vue-cli</li>
<li>Vue路由：vue-router</li>
<li>ajax框架：axios</li>
<li>基于Vue的富文本框架：quill-editor</li>
</ul>
<p>后端技术：

</p>
<ul>
<li>基础的SpringMVC、Spring 5.0和MyBatis3</li>
<li>Spring Boot 2.0.1版本</li>
<li>Spring Cloud 最新版 Finchley.RC1</li>
<li>Redis-4.0</li>
<li>RabbitMQ-3.4</li>
<li>Elasticsearch-5.6.8</li>
<li>nginx-1.10.2：</li>
<li>FastDFS - 5.0.8</li>
<li>MyCat</li>
<li>Thymeleaf</li>
</ul>
<h2>3.2.开发环境</h2>
<p>为了保证开发环境的统一，希望每个人都按照我的环境来配置：

</p>
<ul>
<li>IDE：我们使用Idea 2017.3 版本</li>
<li>JDK：统一使用JDK1.8</li>
<li>项目构建：maven3.3.9以上版本即可</li>
<li>版本控制工具：git</li>
</ul>
<p>idea大家可以在我的课前资料中找到。另外，使用帮助大家可以参考课前资料的《idea使用指南.md》



</p>
<h2>3.3.域名</h2>
<p>我们在开发的过程中，为了保证以后的生产、测试环境统一。尽量都采用域名来访问项目。

</p>
<p>一级域名：www.leyou.com

</p>
<p>二级域名：manage.leyou.com , api.leyou.com

</p>
<p>我们可以通过switchhost工具来修改自己的host对应的地址，只要把这些域名指向127.0.0.1，那么跟你用localhost的效果是完全一样的。

</p>
<p>switchhost可以去课前资料寻找。



</p>
<h2>3.4.创建父工程</h2>
<p>创建统一的父工程：leyou，用来管理依赖及其版本，注意是创建project，而不是moudle

</p>
<p><img src="assets/1525706200704.png" alt="1525706200704">

</p>
<p>填写项目信息：

</p>
<p><img src="assets/1525707023009.png" alt="1525707023009">

</p>
<p>注意：

</p>
<p>父工程不需要代码，只是管理依赖，因此我们不选择任何SpringCloud的依赖

</p>
<p>跳过依赖选择。



</p>
<p>填写保存的位置信息：

</p>
<p><img src="assets/1525706600181.png" alt="1525706600181">

</p>
<p>然后将pom文件修改成我这个样子：

</p>
<pre><code class="lang-xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;groupId&gt;com.leyou.parent&lt;/groupId&gt;
    &lt;artifactId&gt;leyou&lt;/artifactId&gt;
    &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt;
    &lt;packaging&gt;pom&lt;/packaging&gt;

    &lt;name&gt;leyou&lt;/name&gt;
    &lt;description&gt;Demo project for Spring Boot&lt;/description&gt;

    &lt;parent&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
        &lt;version&gt;2.0.1.RELEASE&lt;/version&gt;
        &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;
    &lt;/parent&gt;

    &lt;properties&gt;
        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
        &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;
        &lt;java.version&gt;1.8&lt;/java.version&gt;
        &lt;spring-cloud.version&gt;Finchley.RC1&lt;/spring-cloud.version&gt;
        &lt;mybatis.starter.version&gt;1.3.2&lt;/mybatis.starter.version&gt;
        &lt;mapper.starter.version&gt;2.0.2&lt;/mapper.starter.version&gt;
        &lt;druid.starter.version&gt;1.1.9&lt;/druid.starter.version&gt;
        &lt;mysql.version&gt;5.1.32&lt;/mysql.version&gt;
        &lt;pageHelper.starter.version&gt;1.2.3&lt;/pageHelper.starter.version&gt;
        &lt;leyou.latest.version&gt;1.0.0-SNAPSHOT&lt;/leyou.latest.version&gt;
        &lt;fastDFS.client.version&gt;1.26.1-RELEASE&lt;/fastDFS.client.version&gt;
    &lt;/properties&gt;

    &lt;dependencyManagement&gt;
        &lt;dependencies&gt;
            &lt;!-- springCloud --&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
                &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;
                &lt;version&gt;${spring-cloud.version}&lt;/version&gt;
                &lt;type&gt;pom&lt;/type&gt;
                &lt;scope&gt;import&lt;/scope&gt;
            &lt;/dependency&gt;
            &lt;!-- mybatis启动器 --&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;
                &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;
                &lt;version&gt;${mybatis.starter.version}&lt;/version&gt;
            &lt;/dependency&gt;
            &lt;!-- 通用Mapper启动器 --&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;tk.mybatis&lt;/groupId&gt;
                &lt;artifactId&gt;mapper-spring-boot-starter&lt;/artifactId&gt;
                &lt;version&gt;${mapper.starter.version}&lt;/version&gt;
            &lt;/dependency&gt;
            &lt;!-- 分页助手启动器 --&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt;
                &lt;artifactId&gt;pagehelper-spring-boot-starter&lt;/artifactId&gt;
                &lt;version&gt;${pageHelper.starter.version}&lt;/version&gt;
            &lt;/dependency&gt;
            &lt;!-- mysql驱动 --&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;mysql&lt;/groupId&gt;
                &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
                &lt;version&gt;${mysql.version}&lt;/version&gt;
            &lt;/dependency&gt;
            &lt;!--FastDFS客户端--&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;com.github.tobato&lt;/groupId&gt;
                &lt;artifactId&gt;fastdfs-client&lt;/artifactId&gt;
                &lt;version&gt;${fastDFS.client.version}&lt;/version&gt;
            &lt;/dependency&gt;
          &lt;/dependencies&gt;
    &lt;/dependencyManagement&gt;

    &lt;build&gt;
        &lt;plugins&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
            &lt;/plugin&gt;
        &lt;/plugins&gt;
    &lt;/build&gt;

    &lt;repositories&gt;
        &lt;repository&gt;
            &lt;id&gt;spring-milestones&lt;/id&gt;
            &lt;name&gt;Spring Milestones&lt;/name&gt;
            &lt;url&gt;https://repo.spring.io/milestone&lt;/url&gt;
            &lt;snapshots&gt;
                &lt;enabled&gt;false&lt;/enabled&gt;
            &lt;/snapshots&gt;
        &lt;/repository&gt;
    &lt;/repositories&gt;
&lt;/project&gt;</code></pre>
<p>可以发现，我们在父工程中引入了SpringCloud等很多以后需要用到的依赖，以后创建的子工程就不需要自己引入了。



</p>
<p>最后，删除自动生成的LeyouApplication启动类、测试类以及application.properties文件，我们不需要。

</p>
<h2>3.5.创建EurekaServer</h2>
<h3>3.5.1.创建工程</h3>
<p>这个大家应该比较熟悉了。

</p>
<p>我们的注册中心，起名为：ly-registry

</p>
<p>这次我们就不Spring使用提供的脚手架了。直接创建maven项目，自然会继承父类的依赖：

</p>
<p>选择新建module：

</p>
<p>​    <img src="assets/1525707765104.png" alt="1525707765104">

</p>
<p>选择maven安装，但是不要选择骨架：

</p>
<p><img src="assets/1525707850047.png" alt="1525707850047">

</p>
<p>然后填写项目坐标，我们的项目名称为ly-registry:

</p>
<p><img src="assets/1525707949252.png" alt="1525707949252">

</p>
<p>选择安装目录，因为是聚合项目，目录应该是在父工程leyou的下面：

</p>
<p><img src="assets/1525708053551.png" alt="1525708053551">



</p>
<h3>3.5.2.添加依赖</h3>
<p>添加EurekaServer的依赖：

</p>
<pre><code class="lang-xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;
    &lt;parent&gt;
        &lt;artifactId&gt;leyou&lt;/artifactId&gt;
        &lt;groupId&gt;com.leyou.parent&lt;/groupId&gt;
        &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt;
    &lt;/parent&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;groupId&gt;com.leyou.common&lt;/groupId&gt;
    &lt;artifactId&gt;ly-registry&lt;/artifactId&gt;
    &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt;

    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/project&gt;</code></pre>
<h3>3.5.3.编写启动类</h3>
<pre><code class="lang-java">@SpringBootApplication
@EnableEurekaServer
public class LyRegistry {
    public static void main(String[] args) {
        SpringApplication.run(LyRegistry.class, args);
    }
}</code></pre>
<h3>3.5.4.配置文件</h3>
<pre><code class="lang-yaml">server:
  port: 10086
spring:
  application:
    name: ly-registry
eureka:
  client:
    fetch-registry: false
    register-with-eureka: false
    service-url:
      defaultZone: http://127.0.0.1:${server.port}/eureka
  server:
    enable-self-preservation: false # 关闭自我保护
    eviction-interval-timer-in-ms: 5000 # 每隔5秒进行一次服务列表清理</code></pre>
<h3>3.5.5.项目的结构：</h3>
<p>目前，整个项目的结构如图：

</p>
<p> <img src="assets/1525708460522.png" alt="1525708460522">



</p>
<h2>3.6.创建Zuul网关</h2>
<h3>3.6.1.创建工程</h3>
<p>与上面类似，选择maven方式创建Module，然后填写项目名称，我们命名为：ly-api-gateway

</p>
<p><img src="assets/1525708626562.png" alt="1525708626562">

</p>
<p>填写保存的目录：

</p>
<p><img src="assets/1525708677719.png" alt="1525708677719">

</p>
<h3>3.6.2.添加依赖</h3>
<p>这里我们需要添加Zuul和EurekaClient的依赖：

</p>
<pre><code class="lang-xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;
    &lt;parent&gt;
        &lt;artifactId&gt;leyou&lt;/artifactId&gt;
        &lt;groupId&gt;com.leyou.parent&lt;/groupId&gt;
        &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt;
    &lt;/parent&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;groupId&gt;com.leyou.common&lt;/groupId&gt;
    &lt;artifactId&gt;ly-api-gateway&lt;/artifactId&gt;
    &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt;

    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-netflix-zuul&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;!--是springboot提供的微服务检测接口，默认对外提供几个接口：/info--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/project&gt;</code></pre>
<h3>3.6.3.编写启动类</h3>
<pre><code class="lang-java">@SpringBootApplication
@EnableDiscoveryClient
@EnableZuulProxy
public class LyApiGateway {
    public static void main(String[] args) {
        SpringApplication.run(LyApiGateway.class, args);
    }
}</code></pre>
<h3>3.6.4.配置文件</h3>
<pre><code class="lang-yaml">server:
  port: 10010
spring:
  application:
    name: api-gateway
eureka:
  client:
    service-url:
      defaultZone: http://127.0.0.1:10086/eureka
    registry-fetch-interval-seconds: 5
  instance:
    prefer-ip-address: true
    ip-address: 127.0.0.1
    instance-id: ${spring.application.name}:${server.port}
zuul:
  prefix: /api # 添加路由前缀
  retryable: true
ribbon:
  ConnectTimeout: 250 # 连接超时时间(ms)
  ReadTimeout: 2000 # 通信超时时间(ms)
  OkToRetryOnAllOperations: true # 是否对所有操作重试
  MaxAutoRetriesNextServer: 1 # 同一服务不同实例的重试次数
  MaxAutoRetries: 1 # 同一实例的重试次数
hystrix:
  command:
    default:
      execution:
        isolation:
          thread:
            timeoutInMillisecond: 10000 # 熔断超时时长：10000ms</code></pre>
<h3>3.6.5.项目结构</h3>
<p>目前，leyou下有两个子模块：

</p>
<ul>
<li>ly-registry：服务的注册中心（EurekaServer）</li>
<li>ly-api-gateway：服务网关（Zuul）</li>
</ul>
<p>目前，服务的结构如图所示：

</p>
<pre><code> ![1525709241440](assets/1525709241440.png)</code></pre>
<p>截止到这里，我们已经把基础服务搭建完毕，为了便于开发，统一配置中心（ConfigServer）我们留待以后添加。



</p>
<h2>3.7.创建商品微服务</h2>
<p>既然是一个全品类的电商购物平台，那么核心自然就是商品。因此我们要搭建的第一个服务，就是商品微服务。其中会包含对于商品相关的一系列内容的管理，包括：

</p>
<ul>
<li>商品分类管理</li>
<li>品牌管理</li>
<li>商品规格参数管理</li>
<li>商品管理</li>
<li>库存管理</li>
</ul>
<p>我们先完成项目的搭建：

</p>
<h3>3.7.1.微服务的结构</h3>
<p>因为与商品的品类相关，我们的工程命名为<code>ly-item</code>.

</p>
<p>需要注意的是，我们的ly-item是一个微服务，那么将来肯定会有其它系统需要来调用服务中提供的接口，因此肯定也会使用到接口中关联的实体类。

</p>
<p>因此这里我们需要使用聚合工程，将要提供的接口及相关实体类放到独立子工程中，以后别人引用的时候，只需要知道坐标即可。

</p>
<p>我们会在ly-item中创建两个子工程：

</p>
<ul>
<li>ly-item-interface：主要是对外暴露的接口及相关实体类</li>
<li>ly-item-service：所有业务逻辑及内部使用接口</li>
</ul>
<p>调用关系如图所示：

</p>
<p><img src="assets/1525744281610.png" alt="1525744281610">

</p>
<h3>3.7.2.创建父工程ly-item</h3>
<p>依然是使用maven构建：

</p>
<p><img src="assets/1525744570533.png" alt="1525744570533">

</p>
<p>保存的位置：

</p>
<p><img src="assets/1525744595793.png" alt="1525744595793">

</p>
<p>不需要任何依赖，我们可以把项目打包方式设置为pom

</p>
<pre><code class="lang-xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;
    &lt;parent&gt;
        &lt;artifactId&gt;leyou&lt;/artifactId&gt;
        &lt;groupId&gt;com.leyou.parent&lt;/groupId&gt;
        &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt;
    &lt;/parent&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;groupId&gt;com.leyou.service&lt;/groupId&gt;
    &lt;artifactId&gt;ly-item&lt;/artifactId&gt;
    &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt;
    &lt;!-- 打包方式为pom --&gt;
    &lt;packaging&gt;pom&lt;/packaging&gt;
&lt;/project&gt;</code></pre>
<h3>3.7.3.创建ly-item-interface</h3>
<p>在ly-item工程上点击右键，选择new &gt; module:

</p>
<p> <img src="assets/1525744768694.png" alt="1525744768694">

</p>
<p>依然是使用maven构建，注意父工程是ly-item：

</p>
<p><img src="assets/1525744875078.png" alt="1525744875078">

</p>
<p><strong>注意</strong>：接下来填写的目录结构需要自己手动完成，保存到<code>ly-item</code>下的<code>ly-item-interface</code>目录中：

</p>
<p><img src="assets/1525744973026.png" alt="1525744973026">

</p>
<p>点击Finish完成。

</p>
<p>此时的项目结构：

</p>
<p>​    <img src="assets/1525745119573.png" alt="1525745119573">

</p>
<h3>3.7.4.创建ly-item-service</h3>
<p>与<code>ly-item-interface</code>类似，我们选择在<code>ly-item</code>上右键，新建module，然后填写项目信息：

</p>
<p><img src="assets/1525745247195.png" alt="1525745247195">

</p>
<p>填写存储位置，是在<code>/ly-item/ly-item-service</code>目录

</p>
<p><img src="assets/1525745303365.png" alt="1525745303365">

</p>
<p>点击Finish完成。

</p>
<h3>3.7.5.整个微服务结构</h3>
<p>如图所示：

</p>
<p>​    <img src="assets/1525745407047.png" alt="1525745407047">

</p>
<p>我们打开ly-item的pom查看，会发现ly-item-interface和ly-item-service都已经称为module了：

</p>
<p>​    <img src="assets/1525745475108.png" alt="1525745475108">

</p>
<h3>3.7.6.添加依赖</h3>
<p>接下来我们给<code>ly-item-service</code>中添加依赖：

</p>
<p>思考一下我们需要什么？

</p>
<ul>
<li>Eureka客户端</li>
<li>web启动器</li>
<li>mybatis启动器</li>
<li>通用mapper启动器</li>
<li>分页助手启动器</li>
<li>连接池，我们用默认的Hykira</li>
<li>mysql驱动</li>
<li>千万不能忘了，我们自己也需要<code>ly-item-interface</code>中的实体类</li>
</ul>
<p>这些依赖，我们在顶级父工程：leyou中已经添加好了。所以直接引入即可：

</p>
<pre><code class="lang-xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;
    &lt;parent&gt;
        &lt;artifactId&gt;ly-item&lt;/artifactId&gt;
        &lt;groupId&gt;com.leyou.service&lt;/groupId&gt;
        &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt;
    &lt;/parent&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;groupId&gt;com.leyou.service&lt;/groupId&gt;
    &lt;artifactId&gt;ly-item-service&lt;/artifactId&gt;
    &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt;

    &lt;dependencies&gt;
        &lt;!--Eureka客户端--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;!--web启动器--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;!-- mybatis启动器 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;
            &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;
            &lt;version&gt;${mybatis.starter.version}&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;!-- 通用Mapper启动器 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;tk.mybatis&lt;/groupId&gt;
            &lt;artifactId&gt;mapper-spring-boot-starter&lt;/artifactId&gt;
            &lt;version&gt;${mapper.starter.version}&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;!-- 分页助手启动器 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt;
            &lt;artifactId&gt;pagehelper-spring-boot-starter&lt;/artifactId&gt;
            &lt;version&gt;${pageHelper.starter.version}&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;!-- mysql驱动 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;mysql&lt;/groupId&gt;
            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
            &lt;version&gt;${mysql.version}&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.leyou.service&lt;/groupId&gt;
            &lt;artifactId&gt;ly-item-interface&lt;/artifactId&gt;
            &lt;version&gt;${leyou.latest.version}&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/project&gt;</code></pre>
<p>ly-item-interface中需要什么我们暂时不清楚，所以先不管。

</p>
<p>整个结构：

</p>
<p> <img src="assets/1525747398193.png" alt="1525747398193">



</p>
<h3>3.7.7.编写启动和配置</h3>
<p>在整个<code>ly-item工程</code>中，只有<code>ly-item-service</code>是需要启动的。因此在其中编写启动类即可：

</p>
<pre><code class="lang-java">@SpringBootApplication
@EnableDiscoveryClient
public class LyItemService {
    public static void main(String[] args) {
        SpringApplication.run(LyItemService.class, args);
    }
}</code></pre>
<p>然后是全局属性文件：

</p>
<pre><code class="lang-yaml">server:
  port: 8081
spring:
  application:
    name: item-service
  datasource:
    url: jdbc:mysql://localhost:3306/heima
    username: root
    password: 123
    hikari:
      maximum-pool-size: 30
      minimum-idle: 10
eureka:
  client:
    service-url:
      defaultZone: http://127.0.0.1:10086/eureka
  instance:
    lease-renewal-interval-in-seconds: 5 # 每隔5秒发送一次心跳
    lease-expiration-duration-in-seconds: 10 # 10秒不发送就过期
    prefer-ip-address: true
    ip-address: 127.0.0.1
    instance-id: ${spring.application.name}:${server.port}</code></pre>
<h2>3.8.添加商品微服务的路由规则</h2>
<p>既然商品微服务已经创建，接下来肯定要添加路由规则到Zuul中，我们不使用默认的路由规则。

</p>
<pre><code class="lang-yaml">zuul:
  prefix: /api # 添加路由前缀
  retryable: true
  routes:
    item-service: /item/** # 将商品微服务映射到/item/**</code></pre>
<h2>3.9.启动测试</h2>
<p>我们分别启动：ly-registry，ly-api-gateway，ly-item-service

</p>
<p> <img src="assets/1525749186008.png" alt="1525749186008">

</p>
<p>查看Eureka面板：

</p>
<p><img src="assets/1525749215954.png" alt="1525749215954">



</p>
<h2>3.10.测试路由规则</h2>
<p>为了测试路由规则是否畅通，我们是不是需要在item-service中编写一个controller接口呢？

</p>
<p>其实不需要，Spring提供了一个依赖：actuator

</p>
<p>只要我们添加了actuator的依赖，它就会为我们生成一系列的访问接口：

</p>
<ul>
<li>/info</li>
<li>/health</li>
<li>/refresh</li>
<li>...</li>
</ul>
<p>添加依赖：

</p>
<pre><code class="lang-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;
&lt;/dependency&gt;</code></pre>
<p>重启后访问Eureka控制台：

</p>
<p>鼠标悬停在item-service上，会显示一个地址：

</p>
<p><img src="assets/1525749683060.png" alt="1525749683060">

</p>
<p>这就是actuator提供的接口，我们点击访问：

</p>
<p> <img src="assets/1525749711606.png" alt="1525749711606">

</p>
<p>因为我们没有添加信息，所以是一个空的json，但是可以肯定的是：我们能够访问到item-service了。

</p>
<p>接下来我们通过路由访问试试，根据路由规则，我们需要访问的地址是：

</p>
<p><a href="http://127.0.0.1:10010/api/item/actuator/info">http://127.0.0.1:10010/api/item/actuator/info</a>

</p>
<p> <img src="assets/1525749803191.png" alt="1525749803191">



</p>
<h2>3.11.通用工具模块</h2>
<p>有些工具或通用的约定内容，我们希望各个服务共享，因此需要创建一个工具模块：<code>ly-common</code>



</p>
<p>使用maven来构建module：

</p>
<p><img src="assets/1526046318620.png" alt="1526046318620">

</p>
<p>位置信息：

</p>
<p><img src="assets/1526046349379.png" alt="1526046349379">



</p>
<p>结构：

</p>
<p> <img src="assets/1526046432347.png" alt="1526046432347">

</p>
<p>目前还不需要编码。





</p>
<h1>4、ES6 语法指南</h1>
<p>后端项目搭建完毕，接下来就是前端页面了。不过在这之前需要一些准备工作。我们需要学习ES6的语法标准。

</p>
<p>什么是ES6？就是ECMAScript第6版标准。

</p>
<h2>4.1.什么是ECMAScript？</h2>
<p>来看下前端的发展历程：

</p>
<blockquote>
<p>web1.0时代：

</p>
</blockquote>
<ul>
<li>最初的网页以HTML为主，是纯静态的网页。网页是只读的，信息流只能从服务的到客户端单向流通。<strong>开发人员也只关心页面的样式和内容</strong>即可。</li>
</ul>
<blockquote>
<p>web2.0时代：

</p>
</blockquote>
<ul>
<li>1995年，网景工程师Brendan Eich 花了10天时间设计了JavaScript语言。</li>
<li>1996年，微软发布了JScript，其实是JavaScript的逆向工程实现。</li>
<li>1997年，为了统一各种不同script脚本语言，ECMA（欧洲计算机制造商协会）以JavaScript为基础，制定了<code>ECMAscript</code>标准规范。JavaScript和JScript都是<code>ECMAScript</code>的标准实现者，随后各大浏览器厂商纷纷实现了<code>ECMAScript</code>标准。</li>
</ul>
<p>所以，ECMAScript是浏览器脚本语言的规范，而各种我们熟知的js语言，如JavaScript则是规范的具体实现。

</p>
<h2>4.2.ECMAScript的快速发展</h2>
<p>而后，ECMAScript就进入了快速发展期。

</p>
<ul>
<li><p>1998年6月，ECMAScript 2.0 发布。</p>
</li>
<li><p>1999年12月，ECMAScript 3.0 发布。这时，ECMAScript 规范本身也相对比较完善和稳定了，但是接下来的事情，就比较悲剧了。</p>
</li>
<li><p>2007年10月。。。。ECMAScript 4.0 草案发布。</p>
<p>这次的新规范，历时颇久，规范的新内容也有了很多争议。在制定ES4的时候，是分成了两个工作组同时工作的。</p>
<ul>
<li>一边是以 Adobe, Mozilla, Opera 和 Google为主的 ECMAScript 4 工作组。</li>
<li>一边是以 Microsoft 和 Yahoo 为主的 ECMAScript 3.1 工作组。</li>
</ul>
<p>ECMAScript 4 的很多主张比较激进，改动较大。而 ECMAScript 3.1 则主张小幅更新。最终经过 TC39 的会议，决定将一部分不那么激进的改动保留发布为 ECMAScript 3.1，而ES4的内容，则延续到了后来的ECMAScript5和6版本中</p>
</li>
<li><p>2009年12月，ECMAScript 5 发布。</p>
</li>
<li><p>2011年6月，ECMAScript 5.1 发布。</p>
</li>
<li><p>2015年6月，ECMAScript 6，也就是 ECMAScript 2015 发布了。 并且从 ECMAScript 6 开始，开始采用年号来做版本。即 ECMAScript 2015，就是ECMAScript6。 </p>
</li>
</ul>
<h2>4.3.ES5和6的一些新特性</h2>
<p>我们这里只把一些常用的进行学习，更详细的大家参考：<a href="http://es6.ruanyifeng.com/?search=reduce&amp;x=0&amp;y=0#README">阮一峰的ES6教程</a>

</p>
<h3>4.3.1.let 和 const 命令</h3>
<blockquote>
<p>var

</p>
</blockquote>
<p>之前，js定义变量只有一个关键字：<code>var</code>

</p>
<p><code>var</code>有一个问题，就是定义的变量有时会莫名奇妙的成为全局变量。

</p>
<p>例如这样的一段代码：

</p>
<pre><code class="lang-js">for(var i = 0; i &lt; 5; i++){
    console.log(i);
}
console.log("循环外：" + i)</code></pre>
<p>你猜下打印的结果是什么？

</p>
<p> <img src="assets/1526107278999.png" alt="1526107278999">



</p>
<blockquote>
<p>let

</p>
</blockquote>
<p><code>let</code>所声明的变量，只在<code>let</code>命令所在的代码块内有效。

</p>
<p>我们把刚才的<code>var</code>改成<code>let</code>试试：

</p>
<pre><code class="lang-js">for(let i = 0; i &lt; 5; i++){
    console.log(i);
}
console.log("循环外：" + i)</code></pre>
<p>结果：

</p>
<p> <img src="assets/1526107347275.png" alt="1526107347275">

</p>
<blockquote>
<p>const

</p>
</blockquote>
<p><code>const</code>声明的变量是常量，不能被修改

</p>
<p> <img src="assets/1526107425000.png" alt="1526107425000">



</p>
<h3>4.3.2.字符串扩展</h3>
<blockquote>
<p>新的API

</p>
</blockquote>
<p>ES6为字符串扩展了几个新的API：

</p>
<ul>
<li><code>includes()</code>：返回布尔值，表示是否找到了参数字符串。</li>
<li><code>startsWith()</code>：返回布尔值，表示参数字符串是否在原字符串的头部。</li>
<li><code>endsWith()</code>：返回布尔值，表示参数字符串是否在原字符串的尾部。</li>
</ul>
<p>实验一下：

</p>
<p> <img src="assets/1526107640349.png" alt="1526107640349">



</p>
<blockquote>
<p>字符串模板

</p>
</blockquote>
<p>ES6中提供了`来作为字符串模板标记。我们可以这么玩：

</p>
<p> <img src="assets/1526108070980.png" alt="1526108070980">

</p>
<p>在两个`之间的部分都会被作为字符串的值，不管你任意换行，甚至加入js脚本

</p>
<p>键盘是的1的左侧，tab的上侧，esc的正下方

</p>
<h3>4.3.3.解构表达式</h3>
<blockquote>
<p>数组解构

</p>
</blockquote>
<p>比如有一个数组：

</p>
<pre><code class="lang-js">let arr = [1,2,3]</code></pre>
<p>我想获取其中的值，只能通过角标。ES6可以这样：

</p>
<pre><code class="lang-js">const [x,y,z] = arr;// x，y，z将与arr中的每个位置对应来取值
// 然后打印
console.log(x,y,z);</code></pre>
<p>结果：

</p>
<p> <img src="assets/1526109778368.png" alt="1526109778368">



</p>
<blockquote>
<p>对象解构

</p>
</blockquote>
<p>例如有个person对象：

</p>
<pre><code class="lang-js">const person = {
    name:"jack",
    age:21,
    language: ['java','js','css']
}</code></pre>
<p>我们可以这么做：

</p>
<pre><code class="lang-js">// 解构表达式获取值
const {name,age,language} = person;
// 打印
console.log(name);
console.log(age);
console.log(language);</code></pre>
<p>结果：

</p>
<p> <img src="assets/1526109984544.png" alt="1526109984544">



</p>
<p>如过想要用其它变量接收，需要额外指定别名：

</p>
<p> <img src="assets/1526110159450.png" alt="1526110159450">

</p>
<ul>
<li><code>{name:n}</code>：name是person中的属性名，冒号后面的n是解构后要赋值给的变量。</li>
</ul>
<h3>4.3.4.函数优化</h3>
<blockquote>
<p>函数参数默认值

</p>
</blockquote>
<p>在ES6以前，我们无法给一个函数参数设置默认值，只能采用变通写法：

</p>
<pre><code class="lang-js">    function add(a , b) {
        // 判断b是否为空，为空就给默认值1
        b = b || 1;
        return a + b;
    }
    // 传一个参数
    console.log(add(10));</code></pre>
<p>现在可以这么写：

</p>
<pre><code class="lang-js">function add(a , b = 1) {
    return a + b;
}
// 传一个参数
console.log(add(10));</code></pre>
<blockquote>
<p>箭头函数

</p>
</blockquote>
<p>ES6中定义函数的简写方式：

</p>
<p>一个参数时：

</p>
<pre><code class="lang-js">var print = function (obj) {
    console.log(obj);
}
// 简写为：
var print2 = obj =&gt; console.log(obj);</code></pre>
<p>多个参数：

</p>
<pre><code class="lang-js">// 两个参数的情况：
var sum = function (a , b) {
    return a + b;
}
// 简写为：
var sum2 = (a,b) =&gt; a+b;</code></pre>
<p>代码不止一行，可以用<code>{}</code>括起来

</p>
<pre><code class="lang-js">var sum3 = (a,b) =&gt; {
    return a + b;
}</code></pre>
<blockquote>
<p>对象的函数属性简写

</p>
</blockquote>
<p>比如一个Person对象，里面有eat方法：

</p>
<pre><code class="lang-js">let person = {
    name: "jack",
    // 以前：
    eat: function (food) {
        console.log(this.name + "在吃" + food);
    },
    // 箭头函数版：
    eat2: food =&gt; console.log(person.name + "在吃" + food),// 这里拿不到this
    // 简写版：
    eat3(food){
        console.log(this.name + "在吃" + food);
    }
}</code></pre>
<blockquote>
<p>箭头函数结合解构表达式

</p>
</blockquote>
<p>比如有一个函数：

</p>
<pre><code class="lang-js">const person = {
    name:"jack",
    age:21,
    language: ['java','js','css']
}

function hello(person) {
    console.log("hello," + person.name)
}</code></pre>
<p>如果用箭头函数和解构表达式

</p>
<pre><code class="lang-js">var hi = ({name}) =&gt;  console.log("hello," + name);</code></pre>
<h3>4.3.5.map和reduce</h3>
<p>数组中新增了map和reduce方法。

</p>
<blockquote>
<p>map



</p>
</blockquote>
<p><code>map()</code>：接收一个函数，将原数组中的所有元素用这个函数处理后放入新数组返回。

</p>
<p>举例：有一个字符串数组，我们希望转为int数组

</p>
<pre><code class="lang-js">let arr = ['1','20','-5','3'];
console.log(arr)

arr = arr.map(s =&gt; parseInt(s));

console.log(arr)</code></pre>
<p>  <img src="assets/1526110796839.png" alt="1526110796839">



</p>
<blockquote>
<p>reduce

</p>
</blockquote>
<p><code>reduce()</code>：接收一个函数（必须）和一个初始值（可选），该函数接收两个参数：

</p>
<ul>
<li>第一个参数是上一次reduce处理的结果</li>
<li>第二个参数是数组中要处理的下一个元素</li>
</ul>
<p><code>reduce()</code>会从左到右依次把数组中的元素用reduce处理，并把处理的结果作为下次reduce的第一个参数。如果是第一次，会把前两个元素作为计算参数，或者把用户指定的初始值作为起始参数

</p>
<p>举例：

</p>
<pre><code>const arr = [1,20,-5,3]</code></pre>
<p>没有初始值：

</p>
<p> <img src="assets/1526111537204.png" alt="1526111537204">

</p>
<p>指定初始值：

</p>
<p> <img src="assets/1526111580742.png" alt="1526111580742">

</p>
<h3>4.3.6.promise</h3>
<p>所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。

</p>
<p>感觉跟java的Future类很像啊，有木有！

</p>
<p>我们可以通过Promise的构造函数来创建Promise对象，并在内部封装一个异步执行的结果。

</p>
<p>语法：

</p>
<pre><code class="lang-js">const promise = new Promise(function(resolve, reject) {
  // ... 执行异步操作

  if (/* 异步操作成功 */){
    resolve(value);// 调用resolve，代表Promise将返回成功的结果
  } else {
    reject(error);// 调用reject，代表Promise会返回失败结果
  }
});</code></pre>
<p>这样，在promise中就封装了一段异步执行的结果。



</p>
<p>如果我们想要等待异步执行完成，做一些事情，我们可以通过promise的then方法来实现,语法：

</p>
<pre><code class="lang-js">promise.then(function(value){
    // 异步执行成功后的回调
});</code></pre>
<p>如果想要处理promise异步执行失败的事件，还可以跟上catch：

</p>
<pre><code class="lang-js">promise.then(function(value){
    // 异步执行成功后的回调
}).catch(function(error){
    // 异步执行失败后的回调
})</code></pre>
<p>示例：

</p>
<pre><code>const p = new Promise(function (resolve, reject) {
    // 这里我们用定时任务模拟异步
    setTimeout(() =&gt; {
        const num = Math.random();
        // 随机返回成功或失败
        if (num &lt; 0.5) {
            resolve("成功！num:" + num)
        } else {
            reject("出错了！num:" + num)
        }
    }, 300)
})

// 调用promise
p.then(function (msg) {
    console.log(msg);
}).catch(function (msg) {
    console.log(msg);
})</code></pre>
<p>结果：

</p>
<p> <img src="assets/1526113115887.png" alt="1526113115887">

</p>
<p> <img src="assets/1526113140074.png" alt="1526113140074">

</p>
<h3>4.3.7.set和map（了解）</h3>
<p>ES6提供了Set和Map的数据结构。

</p>
<p>Set，本质与数组类似。不同在于Set中只能保存不同元素，如果元素相同会被忽略。跟java很像吧。

</p>
<p>构造函数：

</p>
<pre><code class="lang-js">// Set构造函数可以接收一个数组或空
let set = new Set();
set.add(1);// [1]
// 接收数组
let set2 = new Set([2,3,4,5,5]);// 得到[2,3,4,5]</code></pre>
<p>普通方法：

</p>
<pre><code>set.add(1);// 添加
set.clear();// 清空
set.delete(2);// 删除指定元素
set.has(2); // 判断是否存在
set.keys();// 返回所有key
set.values();// 返回所有值
set.entries();// 返回键值对集合
// 因为set没有键值对，所有其keys、values、entries方法返回值一样的。
set.size; // 元素个数。是属性，不是方法。</code></pre>
<p>map，本质是与Object类似的结构。不同在于，Object强制规定key只能是字符串。而Map结构的key可以是任意对象。即：

</p>
<ul>
<li>object是 <string,object>集合</string,object></li>
<li>map是<object,object>集合</object,object></li>
</ul>
<p>构造函数：

</p>
<pre><code class="lang-js">// map接收一个数组，数组中的元素是键值对数组
const map = new Map([
    ['key1','value1'],
    ['key2','value2'],
])
// 或者接收一个set
const set = new Set([
    ['key1','value1'],
    ['key2','value2'],
])
const map2 = new Map(set)
// 或者其它map
const map3 = new Map(map);</code></pre>
<p>方法：

</p>
<p> <img src="assets/1526114799767.png" alt="1526114799767">

</p>
<h3>4.3.8.模块化</h3>
<h4>4.3.8.1.什么是模块化</h4>
<p>模块化就是把代码进行拆分，方便重复利用。类似java中的导包：要使用一个包，必须先导包。

</p>
<p>而JS中没有包的概念，换来的是 模块。

</p>
<p>模块功能主要由两个命令构成：<code>export</code>和<code>import</code>。

</p>
<ul>
<li><code>export</code>命令用于规定模块的对外接口，</li>
<li><code>import</code>命令用于导入其他模块提供的功能。</li>
</ul>
<h4>4.3.8.2.export</h4>
<p>比如我定义一个js文件:hello.js，里面有一个对象：

</p>
<pre><code class="lang-js">const util = {
    sum(a,b){
        return a + b;
    }
}</code></pre>
<p>我可以使用export将这个对象导出：

</p>
<pre><code class="lang-js">const util = {
    sum(a,b){
        return a + b;
    }
}
export util;</code></pre>
<p>当然，也可以简写为：

</p>
<pre><code class="lang-js">export const util = {
    sum(a,b){
        return a + b;
    }
}</code></pre>
<p><code>export</code>不仅可以导出对象，一切JS变量都可以导出。比如：基本类型变量、函数、数组、对象。

</p>
<p>当要导出多个值时，还可以简写。比如我有一个文件：user.js：

</p>
<pre><code class="lang-js">var name = "jack"
var age = 21
export {name,age}</code></pre>
<blockquote>
<p>省略名称

</p>
</blockquote>
<p>上面的导出代码中，都明确指定了导出的变量名，这样其它人在导入使用时就必须准确写出变量名，否则就会出错。

</p>
<p>因此js提供了<code>default</code>关键字，可以对导出的变量名进行省略

</p>
<p>例如：

</p>
<pre><code class="lang-js">// 无需声明对象的名字
export default {
    sum(a,b){
        return a + b;
    }
}</code></pre>
<p>这样，当使用者导入时，可以任意起名字



</p>
<h4>4.3.8.3.import</h4>
<p>使用<code>export</code>命令定义了模块的对外接口以后，其他 JS 文件就可以通过<code>import</code>命令加载这个模块。

</p>
<p>例如我要使用上面导出的util：

</p>
<pre><code class="lang-js">// 导入util
import util from 'hello.js'
// 调用util中的属性
util.sum(1,2)</code></pre>
<p>要批量导入前面导出的name和age： 

</p>
<pre><code class="lang-js">import {name, age} from 'user.js'

console.log(name + " , 今年"+ age +"岁了")</code></pre>
<p>但是上面的代码暂时无法测试，因为浏览器目前还不支持ES6 的导入和导出功能。除非借助于工具，把ES6 的语法进行编译降级到ES5，比如<code>Babel-cli</code>工具

</p>
<p> 我们暂时不做测试，大家了解即可。



</p>
<h3>4.3.9.对象扩展</h3>
<p>ES6给Object拓展了许多新的方法，如：

</p>
<ul>
<li>keys(obj)：获取对象的所有key形成的数组</li>
<li>values(obj)：获取对象的所有value形成的数组</li>
<li>entries(obj)：获取对象的所有key和value形成的二维数组。格式：<code>[[k1,v1],[k2,v2],...]</code></li>
<li><p>assian(dest, ...src) ：将多个src对象的值 拷贝到 dest中（浅拷贝）。</p>
<p><img src="assets/1527210872966.png" alt="1527210872966"></p>
</li>
</ul>
<h3>4.3.10.数组扩展</h3>
<p>ES6给数组新增了许多方法：

</p>
<ul>
<li>find(callback)：把数组中的元素逐个传递给函数callback执行，如果返回true，则返回该元素</li>
<li>findIndex(callback)：与find类似，不过返回的是品牌到的元素的索引</li>
<li>includes（callback）：与find类似，如果匹配到元素，则返回true，代表找到了。
Edit By <a href="http://mahua.jser.me">MaHua</a></li>
</ul>
</body></html>